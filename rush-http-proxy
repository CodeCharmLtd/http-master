#!/usr/bin/env node

var path = require('path'),
    fs = require('fs'),
    util  = require('util'),
    argv = require('optimist').argv,
    httpProxy = require('http-proxy'),
    crypto = require('crypto'),
    extend = require('extend'),
    net = require('net');

var http = require('http');

var help = [
    "usage: rush-http-proxy [options] ",
    "",
    "Starts a rush-http-daemon server using the specified command-line options",
    "",
    "options:",
    "  --config CONFIGFILE    Location of the configuration file for the proxy server",
    "  --silent            Silence the log output from the proxy server",
    "  --user   USER       User to drop privileges to once server socket is bound",
    "  -h, --help          You're staring at it"
].join('\n');

if (argv.h || argv.help || Object.keys(argv).length === 2) {
  return util.puts(help);
}

var location, config = {},
    target = argv.target;

var jsonLint = require('jsonlint-lines');
var extend = require('extend');
var async = require('async');

var servers = [];


var tcpServers = {};

function getTcpServer(port, host, cb) {
  var entry = (host ? host + ":" + port : port);
  if(tcpServers[entry]) {
    cb(null, tcpServers[entry]);

  }
  else {
    var tcpServer = tcpServers[entry] = net.createServer();
    function handler(err) {
      if(err) return cb(err);
      cb(null, tcpServer);
    }
    if(host)
      tcpServer.listen(port, host, handler);
    else
      tcpServer.listen(port, handler);
    
  }
}


function logError(str) {
  if(argv.silent || config.silent)
    return;
  if(cluster.worker) {
    str = '[' + cluster.worker.id + '] ' + str;
  }
  util.puts(str);
}

var logNotice = logError;

function loadKeysForContext(context) {
  Object.keys(context).forEach(function (key) {
    // If CA certs are specified, load those too.
    if (key === "ca") {
      if(typeof context.ca == 'object') {
        for (var i=0; i < context.ca.length; i++) {
          if (context.ca === undefined) {
            context.ca = [];
          }
          context.ca[i] = fs.readFileSync(context[key][i], 'utf8');
        }
      }
      else {
        var chain = fs.readFileSync(context.ca, 'utf8');
        chain = chain.split("\n");
        context.ca = [];
        var cert = [];
        chain.forEach(function(line) {
          if(line.length == 0)
            return;
          cert.push(line);
          if(line.match(/-END CERTIFICATE-/)) {
            context.ca.push(cert.join("\n"))
            cert = [];
          }
        });
      }
    } else if(key !== 'SNI' && key !== 'SNICallback') {
      context[key] = fs.readFileSync(context[key], 'utf8');
    }
  });
}

function parseConfig(noExitOnError) {
  //
  // If we were passed a config, parse it
  //
  try {
    var data = fs.readFileSync(argv.config).toString("utf8");
    data = data.replace("\n", "\r\n");
    config = jsonLint.parse(data);
  } catch (ex) {
    logError('Config ' + ex);
    if(!noExitOnError)
      process.exit(1);
    return false;
  }
  return true;
}

function handleConfigEntry(config, callback) {
  //
  // If `config.https` is set, then load the required file contents into the config options.
  //
  if (config.https) {
    var SNI = config.https.SNI;
    var SNImatchers = {};
    if(config.https.SNI) {
      for(key in config.https.SNI) {
          SNImatchers[key] = new RegExp("^" + key + "$", 'i'); // domain names are case insensitive
      }
      config.https.SNICallback = function(hostname) {
        for(key in SNI) {
          if(hostname.match(SNImatchers[key])) {
            return SNI[key];
          }
        }
      }
    }

    loadKeysForContext(config.https);
    if(SNI) {
      for(key in SNI) {
        loadKeysForContext(SNI[key]);
        SNI[key] = crypto.createCredentials(SNI[key]).context;
      }
    }
  }

  //
  // Check to see if we should silence the logs
  //
  config.silent = typeof argv.silent !== 'undefined' ? argv.silent : config.silent;


  var args = [];

  if(config.redirect) {

    var redirectTable = {};

    Object.keys(config.redirect).forEach(function(redirectEntry) {
      var array = redirectEntry.split(/\/(.+)?/);
      var host = array[0];
      var path = array[1];

      var target = config.redirect[redirectEntry];

      if(!target.match(/^http:\/\//) || !target.match(/^http:\/\//)) {
        target = "http://" + target;
      }
      target = target.replace('/[path]', '[path]');
      redirectTable[host] = {
        path: path,
        target: target
      };
    });

    args.push(function(req, res, next) {
      var entry = redirectTable[req.headers.host];
      if(!entry) return next();

      if(entry.path && req.url !== entry.path) return next();

      var target = entry.target;
      target = target.replace("[path]", req.url);

      res.statusCode = 302;
      res.setHeader("Location", target);
      res.end();
    });
  }

  var server;
  if (config.targetHost) {
    args.push(config.targetPort);
    args.push(config.targetHost);
  }
  args.push(config);
  try {
    server = httpProxy.createServer.apply(httpProxy, args);
  } catch(err) {
    return callback(err, null);
  }

  function listeningHandler() {
    console.log("Listening again");
    server.removeAllListeners('error'); // remove the below handler
    callback(null, server);
    server.removeListener('error', errorHandler);
  }
  function errorHandler(err) {
    console.log("Once error");
    server.removeAllListeners('listening'); // remove the above handler
    callback(err, server);
    server.removeListener('listening', listeningHandler);
  }


  server.once('listening', listeningHandler);

  server.once('error', errorHandler);


  getTcpServer(config.port, config.host, function(err, tcpServer) {
    if(err) return callback(err, server);

    tcpServer.removeAllListeners();
    tcpServer.on('connection', function(socket) {
      server.emit('connection', socket);
    });
    tcpServer.on('error', function(err) {
      server.emit('error', err);
    });
    tcpServer.on('close', function(err) {
      server.emit('close');
    });
    console.log("Emitting listening");
    server.emit('listening');
  });
    
}

function handleConfig(config) {
  async.parallel(Object.keys(config.ports).map(function(portEntry) {

    return function(asyncCallback) {

      var m;
      // TODO: IPV6?
      if((m = portEntry.match(/((\S+):)?(\d+)(?:(?:\s*=>\s*)?(\S+):(\d+)?)?/))) {
        var host = m[2];
        var port = parseInt(m[3]);
        var targetHost = m[4];
        var targetPort = m[5];

        var portConfig = config.ports[portEntry];
        var configEntry = extend({
           targetHost: targetHost,
           targetPort: targetPort,
           host: host,
           port: port,
        }, portConfig);

        handleConfigEntry(configEntry , function(err, server) {
          var entryString = (configEntry.host?configEntry.host + ":" + configEntry.port: "port " + configEntry.port);
          if(err) {
            logError("Error while starting entry " + entryString + " : " + err.toString());
          }
          if(server) {
            logNotice("Listening on port: " + entryString);
          }
          else
            logNotice("Entry " + entryString + " is unusable");
          asyncCallback(err, server);
        });
      };
    };
  }), function(err, results) {
    if(err) {
      return process.exit();
    }
    logNotice("Start successful");
    process.send("started");
    servers = results;
  });
}

function unbindAll(cb) {
  servers.forEach(function(server){
    server.removeAllListeners();
  });
  cb();
}

function reloadConfigs() {
  if(parseConfig(true)) {
    handleConfig(config);
  }
}

var numCPUs = require('os').cpus().length;
var cluster = require('cluster');

var EventEmitter = require('events').EventEmitter;

if (cluster.isMaster) {
  var startTime = new Date().getTime();

  parseConfig();
  // Fork workers.
    
  function initWorker(cb) {
    var worker = cluster.fork();
    worker.send('start');
    worker.emitter = new EventEmitter();
    worker.on("message", function(message) { worker.emit("msg:" + message); });
    worker.on("listening", function(host, port) {
    });
    worker.once('msg:started', function() {
      cb();
    });
    return worker;
  }

  var worker;
  var workers = [];

  worker = initWorker(function() {
    workers.push(worker);
    async.times( (config.workerCount || argv.workers || numCPUs) -1, function(n, next) {
      workers.push(initWorker(function() {
        next(null);
      }));
    }, function(err) {
      if(err) {
        logError("Workers failed to start");
        process.exit();
      }
      logNotice("All workers started in " + (new Date().getTime() - startTime) + "ms");
    });

  });

  function reloadAllWorkers() {
    
    var startTime = new Date().getTime();

    async.parallel(workers.map(function(worker) {
      return function(asyncCallback) {
        worker.once('msg:unbindFinished', function() { 

          worker.once('msg:started', function() {
            asyncCallback();
          });
          worker.send('reload');
        });
        worker.send('unbind');
      };
    }), function(err) {
      logNotice("All workers reloaded, downtime was " + (new Date().getTime() - startTime) + "ms");
    });;    
  }


  var watch = require('node-watch');

  if(config.watchConfig || argv.watch) {
    watch(argv.config, function() {
      if(!parseConfig(true)) return;
      logNotice("Reloading workers due to config change"); 
      reloadAllWorkers();
    });
  }

  process.on('SIGUSR1', function() {
    logNotice("USR1: Reloading config");
    if(!parseConfig(true)) return;
    reloadAllWorkers();
  });

  cluster.on('exit', function(worker, code, signal) {
    process.exit();
  });
} else {
  var worker = cluster.worker;

  process.on('message', function(msg) {
    process.emit('msg:' + msg) });

  process.on('msg:start', function() {
    parseConfig();
    handleConfig(config);
  });
  process.on('msg:unbind', function() {
    logNotice('Reloading config');
    unbindAll(function() {
      process.send("unbindFinished");
    });
  });
  process.on('msg:reload', function() {
    reloadConfigs();
  });
}


var user = argv.user || config.user;

//
// Drop privileges if requested
//
if (typeof user === 'string') {
    process.setuid(user);
}