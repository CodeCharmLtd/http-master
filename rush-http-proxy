#!/usr/bin/env node

var path = require('path'),
    fs = require('fs'),
    util  = require('util'),
    argv = require('optimist').argv,
    httpProxy = require('http-proxy'),
    crypto = require('crypto'),
    extend = require('extend');

var help = [
    "usage: rush-http-proxy [options] ",
    "",
    "Starts a rush-http-daemon server using the specified command-line options",
    "",
    "options:",
    "  --config CONFIGFILE    Location of the configuration file for the proxy server",
    "  --silent            Silence the log output from the proxy server",
    "  --user   USER       User to drop privileges to once server socket is bound",
    "  -h, --help          You're staring at it"
].join('\n');

if (argv.h || argv.help || Object.keys(argv).length === 2) {
  return util.puts(help);
}

var location, config = {},
    target = argv.target;

var jsonLint = require('jsonlint-lines');
var extend = require('extend');

var servers = [];

function logError(str) {
  if(argv.silent || config.silent)
    return;
  util.puts(str);
}

var logNotice = logError;


function parseConfig(noExitOnError) {
  //
  // If we were passed a config, parse it
  //
  try {
    var data = fs.readFileSync(argv.config).toString("utf8");
    data = data.replace("\n", "\r\n");
    config = jsonLint.parse(data);
  } catch (ex) {
    logError('Config ' + ex);
    if(!noRestart)
      process.exit(1);
    return false;
  }
  return true;
}

function handleConfigEntry(portEntry, config) {
  //
  // If `config.https` is set, then load the required file contents into the config options.
  //
  if (config.https) {
    var SNI = config.https.SNI;
    var SNImatchers = {};
    if(config.https.SNI) {
      for(key in config.https.SNI) {
          SNImatchers[key] = new RegExp("^" + key + "$", 'i'); // domain names are case insensitive
      }
      config.https.SNICallback = function(hostname) {
        for(key in SNI) {
          if(hostname.match(SNImatchers[key])) {
            return SNI[key];
          }
        }
      }
    }

    function loadKeysForContext(context) {
      Object.keys(context).forEach(function (key) {
        // If CA certs are specified, load those too.
        if (key === "ca") {
          if(typeof context.ca == 'object') {
            for (var i=0; i < context.ca.length; i++) {
              if (context.ca === undefined) {
                context.ca = [];
              }
              context.ca[i] = fs.readFileSync(context[key][i], 'utf8');
            }
          }
          else {
            var chain = fs.readFileSync(context.ca, 'utf8');
            chain = chain.split("\n");
            context.ca = [];
            var cert = [];
            chain.forEach(function(line) {
              if(line.length == 0)
                return;
              cert.push(line);
              if(line.match(/-END CERTIFICATE-/)) {
                context.ca.push(cert.join("\n"))
                cert = [];
              }
            });
          }
        } else if(key !== 'SNI' && key !== 'SNICallback') {
          context[key] = fs.readFileSync(context[key], 'utf8');
        }
      });
    }
    loadKeysForContext(config.https);
    if(SNI) {
      for(key in SNI) {
        loadKeysForContext(SNI[key]);
        SNI[key] = crypto.createCredentials(SNI[key]).context;
      }
    }
  }

  //
  // Check to see if we should silence the logs
  //
  config.silent = typeof argv.silent !== 'undefined' ? argv.silent : config.silent;

  //
  // Create the server with the specified options
  //
  var server;
  if (config.targetHost) {
    server = httpProxy.createServer(config.targetPort, config.targetHost, config);
  }
  else if (config.router) {
    server = httpProxy.createServer(config);
  }
  else {
    return false;
  }

  //
  // Start the server
  //
  if (config.host) {
    server.listen(config.port, config.host);
  } else {
    server.listen(config.port);
  }

  server.once('listening', function() {

    if(config.host)
      logNotice('[' + cluster.worker.id + '] Listening on port: ' + config.host + ":" + port);
    else
      logNotice('[' + cluster.worker.id + '] Listening on port: ' + config.port);

    servers.push(server);
  });

  server.on('error', function(err) {
    logError("Error while starting entry for " + (config.host?config.host + ":" + config.port: "port " + config.port) + " : " + err.toString());
    process.exit();
  });

}

function handleConfig(config) {

  Object.keys(config.ports).forEach(function(portEntry) {

    var m;
    // TODO: IPV6?
    if((m = portEntry.match(/((\S+):)?(\d+)(?:(?:\s*=>\s*)?(\S+):(\d+)?)?/))) {
      var host = m[2];
      var port = parseInt(m[3]);
      var targetHost = m[4];
      var targetPort = m[5];

      var portConfig = config.ports[portEntry];

      handleConfigEntry(portEntry, extend({
         targetHost: targetHost,
         targetPort: targetPort,
         host: host,
         port: port,
      }, portConfig));
    }
  });
}

function reloadConfigs() {
  if(parseConfig(true)) {
    servers.forEach(function(server) {
      server.close();
    });
    servers = [];
    handleConfig(config);
  }
}

var numCPUs = require('os').cpus().length;
var cluster = require('cluster');


if (cluster.isMaster) {
  parseConfig();
  // Fork workers.
    
  var worker;
  var workers = [];
  for (var i = 0; i < (config.workerCount || numCPUs); i++) {
    worker = cluster.fork();
    if(i == 0) {
      worker.send('start');
      workers.push(worker);
    }
    else {
      (function(worker) {
        setTimeout(function() {
          worker.send('start');
          workers.push(worker);
        }, config.workersInitDelay || 1000);
      })(worker);
    }
  }

  fs.watchFile(argv.config, function() {
    console.log("Reloading");
    workers.forEach(function(worker) {
      worker.send('reload');
    });
  });

  cluster.on('exit', function(worker, code, signal) {
    process.exit();
  });
} else {
  var worker = cluster.worker;

  process.on('message', function(msg) {
    if(msg == 'start') {
      parseConfig();
      handleConfig(config);
    }
    else if(msg == 'reload') {
      reloadConfigs();
    }
  });
}


var user = argv.user || config.user;

//
// Drop privileges if requested
//
if (typeof user === 'string') {
    process.setuid(user);
}