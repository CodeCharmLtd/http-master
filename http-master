#!/usr/bin/env node

var path = require('path'),
  fs = require('fs'),
  util = require('util'),
  argv = require('optimist').argv,
  crypto = require('crypto'),
  extend = require('extend'),
  net = require('net'),
  http = require('http'),
  https = require('https'),
  jsonLint = require('jsonlint-lines'),
  extend = require('extend'),
  async = require('async');

function logError(str) {
  if (argv.silent || config.silent)
    return;
  console.log(str);
}
var logNotice = logError;

var help = [
  "usage: http-master [options] ",
  "",
  "Starts a http-master server using the specified command-line options",
  "",
  "options:",
  "  --config CONFIGFILE     Location of the configuration file for the proxy server",
  "  --configloader JS-FILE  Provide js file as config loader",
  "  --configloader-test     Test config configloader by printing out its output",
  "  --silent                Silence the log output from the proxy server",
  "  --user   USER           User to drop privileges to once server socket is bound",
  "  --group  GROUP          Group to drop privileges to once server socket is bound",
  "  --show-rules            Show all rules upon every config load",
  "  -h, --help              You're staring at it"
].join('\n');

if (argv.h || argv.help || Object.keys(argv).length === 2) {
  return console.log(help);
}

var location, config = {},
  target = argv.target;

if (argv['configloader-test']) {
  require(argv.configloader)(argv, fs.readFileSync(argv.config).toString("utf8"), function(err, config) {
    if(err) throw err;
    console.log(JSON.stringify(config));
  });
  return;
}

if (!argv.config && !argv.configloader) {
  logError("either --config or --configloader is mandatory");
  process.exit();
}

var common = require('./common');
var runModules = common.runModules;

var droppedPrivileges = false;

function dropPrivileges() {
  var strInfo;
  if (process.setgid) {
    var group = argv.group || config.group;
    if (typeof group === 'string') {
      process.setgid(group);
      strInfo = group;
    }
  }
  if (process.setuid) {
    var user = argv.user || config.user;
    if (typeof user === 'string') {
      process.setuid(user);
      if (strInfo)
        strInfo = user + ":" + strInfo;
      else
        strInfo = user;
    }
  }
  if (!droppedPrivileges && strInfo)
    logNotice("Dropped privileges to: " + strInfo);
  droppedPrivileges = true;
}


var friendlyConfig = require('./friendlyConfig');

function fetchConfig(finish) {

  var configloader;
  if (argv.configloader) {
    configloader = require(argv.configloader);
  } else {
    configloader = function(argv, data, finish) {
      data = data.replace("\n", "\r\n");
      try {
        finish(null, jsonLint.parse(data));
      } catch(err) {
        finish(err);
      }
    };
  }  

  fs.readFile(argv.config, function(err, data) {
    if(err) return finish(err);
    data = data.toString('utf8');
    try {
      configloader(argv, data, function(err, config) {
        if(err) return finish(err);
        config = extend(true, {}, config, friendlyConfig(config));
        if(argv['show-rules'])
          logNotice(config.ports);
        finish(err, config);
      });
    } catch(err) {
      finish(err);
    }

  });

}

var numCPUs = require('os').cpus().length;
// hacky way to ensure that our cluster is a locally loaded one
// use this until https://github.com/joyent/node/pull/3367 is merged
var oldCluster = require.cache[require.resolve('cluster')];
delete require.cache[require.resolve('cluster')];
var cluster = require('cluster');
require.cache[require.resolve('cluster')] = oldCluster;

var EventEmitter = require('events').EventEmitter;

cluster.setupMaster({
  exec: './worker.js',
  args: []
});

var startTime = new Date().getTime();

function initWorker(cb) {
  var worker = cluster.fork();
  worker.sendMessage = function(type, data) {
    worker.send(JSON.stringify({
      type: type,
      data: data
    }));
  };

  worker.sendMessage('start', {
    config: config,
    argv: argv
  });
  worker.emitter = new EventEmitter();
  worker.on("message", function(msg) {
    var msg = JSON.parse(msg);
    process.emit('msg:' + msg.type, msg.data, worker);
    worker.emit('msg:' + msg.type, msg.data);
  });
  worker.on("listening", function(host, port) {});
  worker.once('msg:started', function() {
    cb();
  });
  return worker;
}

fetchConfig(function(err, parsedConfig) {
  if(err) {
    throw err;
  }
  config = parsedConfig;

  var worker;
  var workers = [];

  worker = initWorker(function() {
    workers.push(worker);
    async.times((config.workerCount || argv.workers || numCPUs) - 1, function(n, next) {
      workers.push(initWorker(function() {
        next(null);
      }));
    }, function(err) {
      if (err) {
        logError("Workers failed to start");
        process.exit();
      }
      logNotice("All workers started in " + (new Date().getTime() - startTime) + "ms");
      dropPrivileges();
      runModules("allWorkersStarted", config);

    });

  });

  function reloadAllWorkers() {

    var startTime = new Date().getTime();

    async.parallel(workers
      .filter(function(worker) {
        return !!worker;
      }) // dead workers leave undefined keys
      .map(function(worker) {
        return function(asyncCallback) {
          worker.once('msg:unbindFinished', function() {

            worker.once('msg:started', function() {
              asyncCallback();
            });
            worker.sendMessage('reload', config);
          });
          worker.sendMessage('unbind');
        };
      }), function(err) {
        logNotice("All workers reloaded, downtime was " + (new Date().getTime() - startTime) + "ms");
      });;
  }


  var watch = require('node-watch');

  if (config.watchConfig || argv.watch) {
    watch(argv.config, function() {
      logNotice("Reloading workers due to config change");
      fetchConfig(function(err, parsedConfig) {
        if(err) return logNotice("Skipping reload due to config error");
        config = parsedConfig;
        reloadAllWorkers();        
      });
    });
  }

  process.on('SIGUSR1', function() {
    logNotice("USR1: Reloading config");

    // TODO: assure it is not called in the middle of reload
    fetchConfig(function(err, parsedConfig) {
      if(err) return logNotice("Skipping reload due to config error");
      config = parsedConfig;
      reloadAllWorkers();
    });
  });

  cluster.on('exit', function(worker, code, signal) {
    logError("Worker " + worker.id + " failed with code " + code, "... starting replacement");
    workers[worker.id - 1] = undefined;
    var newWorker = initWorker(function() {
      console.log("Worker", newWorker.id, "started in place of worker", worker.id);
      workers[newWorker.id - 1] = newWorker;
    });
  });

  // patch config for modules to know user/group from argv
  config.user = config.user || argv.user;
  config.group = config.group || argv.group;
  runModules("initMaster", config);

  process.on('uncaughtException', function(err) {
    logError("[Uncaught exception in master] " + err.stack || err.message);
  });

});